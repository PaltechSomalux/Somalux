{"version":3,"file":"static/js/824.3fb3f28d.chunk.js","mappings":"kNAOA,MA6dA,EA7dmBA,KACjB,MAAOC,EAAMC,IAAWC,EAAAA,EAAAA,UAAS,KAC1BC,EAASC,IAAcF,EAAAA,EAAAA,WAAS,IAChCG,EAAQC,IAAaJ,EAAAA,EAAAA,UAAS,CAAEK,KAAM,GAAIC,YAAa,MACvDC,EAAWC,IAAgBR,EAAAA,EAAAA,UAAS,OACpCS,EAAOC,IAAYV,EAAAA,EAAAA,UAAS,CAAEK,KAAM,GAAIC,YAAa,MACrDK,EAAMC,IAAWZ,EAAAA,EAAAA,UAAS,IAC1Ba,IAAYb,EAAAA,EAAAA,UAAS,KACrBc,EAAYC,IAAiBf,EAAAA,EAAAA,UAAS,CAAC,IACvCgB,EAAYC,IAAiBjB,EAAAA,EAAAA,UAAS,KACtCkB,EAAgBC,IAAqBnB,EAAAA,EAAAA,WAAS,IAC9CoB,EAAiBC,IAAsBrB,EAAAA,EAAAA,WAAS,IAEjD,QAAEsB,EAAO,UAAEC,IAAcC,EAAAA,EAAAA,KAEzBC,EAAOC,UACXxB,GAAW,GACX,IACE,MAAMyB,QAAmBC,EAAAA,EAAAA,MACzB7B,EAAQ4B,GAGR,MAAME,EAAS,CAAC,QACVC,QAAQC,IACZJ,EAAWK,IAAIN,UACb,MAAM,MAAEO,EAAK,MAAEC,SAAgBC,EAAAA,EAC5BC,KAAK,SACLC,OAAO,IAAK,CAAEJ,MAAO,QAASK,MAAM,IACpCC,GAAG,cAAeC,EAAIC,IAEpBP,IACHL,EAAOW,EAAIC,IAAMR,GAAS,MAIhClB,EAAcc,EAChB,CAAE,MAAOa,GACPC,QAAQT,MAAM,6BAA8BQ,GAC5CnB,EAAU,CAAEqB,KAAM,QAASC,QAAS,8BACtC,CAAC,QACC3C,GAAW,EACb,IAGF4C,EAAAA,EAAAA,WAAU,KAAQrB,KAAW,IAE7B,MAAMsB,EAAMrB,UACV,GAAKvB,EAAOE,KAAK2C,OAIjB,UACQC,EAAAA,EAAAA,IAAe,CAAE5C,KAAMF,EAAOE,KAAK2C,OAAQ1C,YAAaH,EAAOG,aAAe,KACpFF,EAAU,CAAEC,KAAM,GAAIC,YAAa,WAC7BmB,IACNF,EAAU,CAAEqB,KAAM,UAAWC,QAAS,gCACxC,CAAE,MAAOH,GACPC,QAAQT,MAAM,0BAA2BQ,GACzCnB,EAAU,CAAEqB,KAAM,QAASC,SAAU,OAADH,QAAC,IAADA,OAAC,EAADA,EAAGG,UAAW,2BACpD,MAXEtB,EAAU,CAAEqB,KAAM,QAASC,QAAS,mCAmBlCK,EAASA,KACb1C,EAAa,MACbE,EAAS,CAAEL,KAAM,GAAIC,YAAa,MAG9B6C,EAA4BzB,eAAO0B,GAAsC,IAAxBC,EAAUC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAC3DD,EACFhC,GAAmB,GAEnBF,GAAkB,GAGpB,IACE,MAAMsC,QC4fL/B,eAA2C0B,GAChD,IAIE,MAAMM,EAAS,0DAAAC,OAA6DC,mBAAmBR,GAAa,qEACtGS,QAAiBC,MAAMJ,GAE7B,IAAKG,EAASE,GAAI,OAAO,KAEzB,MACMC,SADaH,EAASI,QACTC,MAAMF,MAInBrD,EAAOqD,EADEG,OAAOC,KAAKJ,GAAO,IAGlC,GAAIrD,EAAK0D,QAAS,CAEhB,IAAI/D,EAAcK,EAAK0D,QAGvB,MAAMC,EAAqBhE,EAAYiE,MAAM,iBAQ7C,OAPID,EACFhE,EAAcgE,EAAmB,GACxBhE,EAAYiD,OAAS,MAE9BjD,EAAcA,EAAYkE,UAAU,EAAG,KAAO,OAGzC,CACLlE,YAAaA,EAAY0C,OACzByB,OAAQ,YAEZ,CAEA,OAAO,IACT,CAAE,MAAOvC,GAEP,OADAS,QAAQT,MAAM,uCAAwCA,GAC/C,IACT,CACF,CDriB2BwC,CAA4BtB,GAE7CK,GAAUA,EAAOnD,aACf+C,EACF3C,GAAQiE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIlE,GAAK,IAAEH,YAAamD,EAAOnD,eAEzCF,GAASuE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIxE,GAAM,IAAEG,YAAamD,EAAOnD,eAE7CiB,EAAU,CAAEqB,KAAM,UAAWC,QAAQ,+BAADc,OAAiCP,EAAY,QAEjF7B,EAAU,CAAEqB,KAAM,OAAQC,QAAQ,6BAADc,OAA+BP,EAAY,8BAEhF,CAAE,MAAOlB,GACPS,QAAQT,MAAM,kCAAmCA,GACjDX,EAAU,CAAEqB,KAAM,QAASC,QAAS,sDACtC,CAAC,QACKQ,EACFhC,GAAmB,GAEnBF,GAAkB,EAEtB,CACF,EAyCMyD,GAAeC,EAAAA,EAAAA,SAAQ,KAC3B,IAAK7D,EAAWgC,OAAQ,OAAOlD,EAC/B,MAAMgF,EAAO9D,EAAW+D,cACxB,OAAOjF,EAAKkF,OAAOC,GACjBA,EAAI5E,KAAK0E,cAAcG,SAASJ,KAC/BG,EAAI3E,aAAe,IAAIyE,cAAcG,SAASJ,KAEhD,CAAChF,EAAMkB,IAEJmE,GAAgBN,EAAAA,EAAAA,SAAQ,KAC5B,MAAMO,GAASzE,EAAO,GAAKE,EACrBwE,EAAMD,EAAQvE,EACpB,OAAO+D,EAAaU,MAAMF,EAAOC,IAChC,CAACT,EAAcjE,EAAME,IAElB0E,GAAaV,EAAAA,EAAAA,SAAQ,IAAMW,KAAKC,IAAI,EAAGD,KAAKE,KAAKd,EAAarB,OAAS1C,IAAY,CAAC+D,EAAarB,OAAQ1C,KAG/GiC,EAAAA,EAAAA,WAAU,KACRlC,EAAQ,IACP,CAACI,IAEJ,MAAM2E,GAAad,EAAAA,EAAAA,SAAQ,IAClBV,OAAOyB,OAAO9E,GAAY+E,OAAO,CAACC,EAAK7D,IAAU6D,EAAM7D,EAAO,GACpE,CAACnB,IAEJ,OACEiF,EAAAA,EAAAA,KAAA,OAAAC,UACEC,EAAAA,EAAAA,MAAA,OAAKC,UAAU,QAAOF,SAAA,EACpBD,EAAAA,EAAAA,KAAA,OAAKG,UAAU,eAAeC,MAAO,CAAEC,aAAc,UAAWJ,UAC9DC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEE,QAAS,OAAQC,WAAY,SAAUC,IAAK,WAAYP,SAAA,EACpED,EAAAA,EAAAA,KAAA,OAAKI,MAAO,CACVK,MAAO,OACPC,OAAQ,OACRC,aAAc,OACdC,WAAY,oDACZN,QAAS,OACTC,WAAY,SACZM,eAAgB,UAChBZ,UACAD,EAAAA,EAAAA,KAACc,EAAAA,IAAQ,CAACC,KAAM,GAAIC,MAAM,YAE5Bd,EAAAA,EAAAA,MAAA,OAAAD,SAAA,EACED,EAAAA,EAAAA,KAAA,OAAKG,UAAU,cAAcC,MAAO,CAAEC,aAAc,WAAYJ,SAAC,gBACjEC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEa,SAAU,WAAYD,MAAO,WAAYf,SAAA,CACpDlG,EAAKyD,OAAO,IAAkB,IAAhBzD,EAAKyD,OAAe,WAAa,aAAa,WAAIoC,EAAW,2BAOpFI,EAAAA,EAAAA,KAAA,OAAKI,MAAO,CAAEC,aAAc,QAASJ,UACnCC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEc,SAAU,YAAajB,SAAA,EACnCD,EAAAA,EAAAA,KAACmB,EAAAA,IAAQ,CACPJ,KAAM,GACNX,MAAO,CACLc,SAAU,WACVE,KAAM,OACNC,IAAK,MACLC,UAAW,mBACXN,MAAO,cAGXhB,EAAAA,EAAAA,KAAA,SACEG,UAAU,QACVoB,MAAOtG,EACPuG,SAAW7E,GAAMzB,EAAcyB,EAAE8E,OAAOF,OACxCG,YAAY,uBACZtB,MAAO,CAAEuB,YAAa,gBAM5BzB,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CACVQ,WAAY,0BACZgB,OAAQ,mCACRjB,aAAc,OACdkB,QAAS,OACTxB,aAAc,UACdJ,SAAA,EACAC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEE,QAAS,OAAQC,WAAY,SAAUC,IAAK,SAAUH,aAAc,WAAYJ,SAAA,EAC5FD,EAAAA,EAAAA,KAAC8B,EAAAA,IAAM,CAACf,KAAM,GAAIC,MAAM,aACxBhB,EAAAA,EAAAA,KAAA,QAAMI,MAAO,CAAEY,MAAO,UAAWe,WAAY,OAAQ9B,SAAC,yBAExDC,EAAAA,EAAAA,MAAA,OAAKC,UAAU,SAASC,MAAO,CAAEC,aAAc,UAAWJ,SAAA,EACxDC,EAAAA,EAAAA,MAAA,OAAAD,SAAA,EACED,EAAAA,EAAAA,KAAA,SAAOG,UAAU,QAAQC,MAAO,CAAEC,aAAc,SAAUY,SAAU,WAAYhB,SAAC,YACjFD,EAAAA,EAAAA,KAAA,SACEG,UAAU,QACVoB,MAAOnH,EAAOE,KACdkH,SAAW7E,GAAMtC,GAASuE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIxE,GAAM,IAAEE,KAAMqC,EAAE8E,OAAOF,SACvDG,YAAY,wBACZtB,MAAO,CAAEa,SAAU,SAAUY,QAAS,iBACtCG,WAAarF,GAAgB,UAAVA,EAAEsF,KAAmBjF,UAG5CkD,EAAAA,EAAAA,MAAA,OAAAD,SAAA,EACED,EAAAA,EAAAA,KAAA,SAAOG,UAAU,QAAQC,MAAO,CAAEC,aAAc,SAAUY,SAAU,WAAYhB,SAAC,iBACjFC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEc,SAAU,YAAajB,SAAA,EACnCD,EAAAA,EAAAA,KAAA,SACEG,UAAU,QACVoB,MAAOnH,EAAOG,YACdiH,SAAW7E,GAAMtC,GAASuE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIxE,GAAM,IAAEG,YAAaoC,EAAE8E,OAAOF,SAC9DG,YAAY,uBACZtB,MAAO,CAAEa,SAAU,SAAUY,QAAS,gBAAiBK,aAAc,QACrEF,WAAarF,GAAgB,UAAVA,EAAEsF,KAAmBjF,OAE1CgD,EAAAA,EAAAA,KAAA,UACEmC,QAASA,IAAM/E,EAA0BhD,EAAOE,MAAM,GACtD8H,UAAWhI,EAAOE,MAAQa,EAC1BiF,MAAO,CACLc,SAAU,WACVmB,MAAO,MACPhB,IAAK,MACLC,UAAW,mBACXV,WAAY,UACZI,MAAO,QACPY,OAAQ,OACRC,QAAS,UACTlB,aAAc,MACd2B,OAAQlI,EAAOE,OAASa,EAAiB,UAAY,cACrD8F,SAAU,OACVsB,QAASnI,EAAOE,OAASa,EAAiB,EAAI,GAC9CmF,QAAS,OACTC,WAAY,SACZC,IAAK,MACLgC,WAAY,UAEdC,MAAM,wBAAuBxC,SAE5B9E,GAAiB+E,EAAAA,EAAAA,MAAAwC,EAAAA,SAAA,CAAAzC,SAAA,EAAED,EAAAA,EAAAA,KAAC2C,EAAAA,IAAQ,CAACxC,UAAU,OAAOC,MAAO,CAAEa,SAAU,UAAY,YAAWjB,EAAAA,EAAAA,KAAA0C,EAAAA,SAAA,CAAAzC,SAAE,qBAKnGD,EAAAA,EAAAA,KAAA,OAAKG,UAAU,UAASF,UACtBC,EAAAA,EAAAA,MAAA,UAAQC,UAAU,cAAcgC,QAASnF,EAAIiD,SAAA,EAC3CD,EAAAA,EAAAA,KAAC8B,EAAAA,IAAM,CAACf,KAAM,KAAM,yBAM1Bf,EAAAA,EAAAA,KAAA,OAAKI,MAAO,CAAEwC,UAAW,QAAS3C,UAChCC,EAAAA,EAAAA,MAAA,SAAOC,UAAU,QAAOF,SAAA,EACtBD,EAAAA,EAAAA,KAAA,SAAAC,UACEC,EAAAA,EAAAA,MAAA,MAAAD,SAAA,EACED,EAAAA,EAAAA,KAAA,MAAII,MAAO,CAAEK,MAAO,OAAQR,SAAC,cAC7BD,EAAAA,EAAAA,KAAA,MAAII,MAAO,CAAEK,MAAO,OAAQR,SAAC,iBAC7BD,EAAAA,EAAAA,KAAA,MAAII,MAAO,CAAEK,MAAO,MAAOoC,UAAW,UAAW5C,SAAC,WAClDD,EAAAA,EAAAA,KAAA,MAAII,MAAO,CAAEK,MAAO,MAAOoC,UAAW,SAAU5C,SAAC,kBAGrDD,EAAAA,EAAAA,KAAA,SAAAC,SACG/F,GACC8F,EAAAA,EAAAA,KAAA,MAAAC,UACED,EAAAA,EAAAA,KAAA,MAAI8C,QAAS,EAAG1C,MAAO,CAAEY,MAAO,UAAW6B,UAAW,SAAUhB,QAAS,QAAS5B,UAChFC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEE,QAAS,OAAQyC,cAAe,SAAUxC,WAAY,SAAUC,IAAK,UAAWP,SAAA,EAC5FD,EAAAA,EAAAA,KAAA,OAAKG,UAAU,UAAUC,MAAO,CAAEK,MAAO,OAAQC,OAAQ,OAAQsC,YAAa,UAC9EhD,EAAAA,EAAAA,KAAA,QAAAC,SAAM,iCAIe,IAAzBb,EAAc5B,QAChBwC,EAAAA,EAAAA,KAAA,MAAAC,UACED,EAAAA,EAAAA,KAAA,MAAI8C,QAAS,EAAG1C,MAAO,CAAEY,MAAO,UAAW6B,UAAW,SAAUhB,QAAS,QAAS5B,UAChFC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEE,QAAS,OAAQyC,cAAe,SAAUxC,WAAY,SAAUC,IAAK,UAAWP,SAAA,EAC5FD,EAAAA,EAAAA,KAACc,EAAAA,IAAQ,CAACC,KAAM,GAAIC,MAAM,aAC1BhB,EAAAA,EAAAA,KAAA,QAAAC,SAAOhF,EAAa,2CAA6C,sBAChEA,IACC+E,EAAAA,EAAAA,KAAA,UACEG,UAAU,MACVgC,QAASA,IAAMjH,EAAc,IAC7BkF,MAAO,CAAE6C,UAAW,UAAWhD,SAChC,wBAOPb,EAAcnD,IAAIiD,IACpBgB,EAAAA,EAAAA,MAAA,MAAAD,SAAA,EACED,EAAAA,EAAAA,KAAA,MAAAC,SACGzF,IAAc0E,EAAIxC,IACjBsD,EAAAA,EAAAA,KAAA,SACEG,UAAU,QACVoB,MAAO7G,EAAMJ,KACbkH,SAAW7E,GAAMhC,GAAQiE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIlE,GAAK,IAAEJ,KAAMqC,EAAE8E,OAAOF,SACrD2B,WAAS,KAGXhD,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEE,QAAS,OAAQC,WAAY,SAAUC,IAAK,UAAWP,SAAA,EACnED,EAAAA,EAAAA,KAAA,OAAKI,MAAO,CACVK,MAAO,OACPC,OAAQ,OACRC,aAAc,MACdC,WAAY,yBACZN,QAAS,OACTC,WAAY,SACZM,eAAgB,SAChBsC,WAAY,GACZlD,UACAD,EAAAA,EAAAA,KAACc,EAAAA,IAAQ,CAACC,KAAM,GAAIC,MAAM,eAE5BhB,EAAAA,EAAAA,KAAA,QAAMI,MAAO,CAAE2B,WAAY,MAAOf,MAAO,WAAYf,SAAEf,EAAI5E,aAIjE0F,EAAAA,EAAAA,KAAA,MAAAC,SACGzF,IAAc0E,EAAIxC,IACjBwD,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CAAEc,SAAU,YAAajB,SAAA,EACnCD,EAAAA,EAAAA,KAAA,SACEG,UAAU,QACVoB,MAAO7G,EAAMH,YACbiH,SAAW7E,GAAMhC,GAAQiE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAIlE,GAAK,IAAEH,YAAaoC,EAAE8E,OAAOF,SAC5DnB,MAAO,CAAE8B,aAAc,WAEzBlC,EAAAA,EAAAA,KAAA,UACEmC,QAASA,IAAM/E,EAA0B1C,EAAMJ,MAAM,GACrD8H,UAAW1H,EAAMJ,MAAQe,EACzB+E,MAAO,CACLc,SAAU,WACVmB,MAAO,MACPhB,IAAK,MACLC,UAAW,mBACXV,WAAY,UACZI,MAAO,QACPY,OAAQ,OACRC,QAAS,UACTlB,aAAc,MACd2B,OAAQ5H,EAAMJ,OAASe,EAAkB,UAAY,cACrD4F,SAAU,OACVsB,QAAS7H,EAAMJ,OAASe,EAAkB,EAAI,GAC9CiF,QAAS,OACTC,WAAY,SACZC,IAAK,MACLgC,WAAY,UAEdC,MAAM,wBAAuBxC,SAE5B5E,GAAkB6E,EAAAA,EAAAA,MAAAwC,EAAAA,SAAA,CAAAzC,SAAA,EAAED,EAAAA,EAAAA,KAAC2C,EAAAA,IAAQ,CAACxC,UAAU,OAAOC,MAAO,CAAEa,SAAU,UAAY,YAAWjB,EAAAA,EAAAA,KAAA0C,EAAAA,SAAA,CAAAzC,SAAE,eAIhGD,EAAAA,EAAAA,KAAA,QAAMI,MAAO,CAAEY,MAAO9B,EAAI3E,YAAc,UAAY,UAAW6I,UAAWlE,EAAI3E,YAAc,SAAW,UAAW0F,SAC/Gf,EAAI3E,aAAe,sBAI1ByF,EAAAA,EAAAA,KAAA,MAAII,MAAO,CAAEyC,UAAW,UAAW5C,UACjCC,EAAAA,EAAAA,MAAA,OAAKE,MAAO,CACVE,QAAS,cACTC,WAAY,SACZC,IAAK,WACLI,WAAY7F,EAAWmE,EAAIxC,IAAM,EAAI,yBAA2B,2BAChEsE,MAAOjG,EAAWmE,EAAIxC,IAAM,EAAI,UAAY,UAC5CmF,QAAS,kBACTlB,aAAc,OACdM,SAAU,WACVc,WAAY,OACZ9B,SAAA,EACAD,EAAAA,EAAAA,KAACqD,EAAAA,IAAU,CAACtC,KAAM,KACjBhG,EAAWmE,EAAIxC,KAAO,QAG3BsD,EAAAA,EAAAA,KAAA,MAAAC,SACGzF,IAAc0E,EAAIxC,IACjBwD,EAAAA,EAAAA,MAAA,OAAKC,UAAU,UAAUC,MAAO,CAAES,eAAgB,YAAaZ,SAAA,EAC7DD,EAAAA,EAAAA,KAAA,UAAQG,UAAU,cAAcgC,QAASA,IAtTlDxG,WACX,GAAKjB,EAAMJ,KAAK2C,OAIhB,UACQqG,EAAAA,EAAAA,IAAe5G,EAAI,CAAEpC,KAAMI,EAAMJ,KAAK2C,OAAQ1C,YAAaG,EAAMH,cACvE4C,UACMzB,IACNF,EAAU,CAAEqB,KAAM,UAAWC,QAAS,kCACxC,CAAE,MAAOH,GACPC,QAAQT,MAAM,6BAA8BQ,GAC5CnB,EAAU,CAAEqB,KAAM,QAASC,SAAU,OAADH,QAAC,IAADA,OAAC,EAADA,EAAGG,UAAW,8BACpD,MAXEtB,EAAU,CAAEqB,KAAM,QAASC,QAAS,oCAoT6ByG,CAAKrE,EAAIxC,IAAK0D,MAAO,CAAEa,SAAU,YAAahB,SAAC,UAG9FD,EAAAA,EAAAA,KAAA,UAAQG,UAAU,MAAMgC,QAAShF,EAAQiD,MAAO,CAAEa,SAAU,YAAahB,SAAC,eAK5EC,EAAAA,EAAAA,MAAA,OAAKC,UAAU,UAAUC,MAAO,CAAES,eAAgB,YAAaZ,SAAA,EAC7DD,EAAAA,EAAAA,KAAA,UACEG,UAAU,MACVgC,QAASA,IA3WdjD,KACjBzE,EAAayE,EAAIxC,IACjB/B,EAAS,CAAEL,KAAM4E,EAAI5E,KAAMC,YAAa2E,EAAI3E,aAAe,MAyWtBiJ,CAAUtE,GACzBkB,MAAO,CAAEyB,QAAS,SAAU4B,SAAU,QACtChB,MAAM,gBAAexC,UAErBD,EAAAA,EAAAA,KAAC0D,EAAAA,IAAO,CAAC3C,KAAM,QAEjBf,EAAAA,EAAAA,KAAA,UACEG,UAAU,MACVgC,QAASA,IAzTZxG,WACnB,MAAMgI,EAAY5I,EAAWmE,EAAIxC,KAAO,EAUxC,SATiBnB,EAAQ,CACvBkH,MAAO,mBACP3F,QAAS6G,EAAY,EAAC,0BAAA/F,OACQ+F,EAAS,SAAA/F,OAAQ+F,EAAY,EAAI,IAAM,GAAE,wEACnE,8CACJC,aAAc,SACdC,YAAa,SACbC,QAAS,WAGX,UACQC,EAAAA,EAAAA,IAAe7E,EAAIxC,UACnBhB,IACNF,EAAU,CAAEqB,KAAM,UAAWC,QAAS,kCACxC,CAAE,MAAOH,GACPC,QAAQT,MAAM,6BAA8BQ,GAC5CnB,EAAU,CAAEqB,KAAM,QAASC,SAAU,OAADH,QAAC,IAADA,OAAC,EAADA,EAAGG,UAAW,8BACpD,GAsSqCkH,CAAa9E,GAC5BkB,MAAO,CAAEyB,QAAS,SAAU4B,SAAU,OAAQzC,MAAO,WACrDyB,MAAM,kBAAiBxC,UAEvBD,EAAAA,EAAAA,KAACiE,EAAAA,IAAQ,CAAClD,KAAM,cA9GjB7B,EAAIxC,YA0HpBmC,EAAarB,OAAS,IACrB0C,EAAAA,EAAAA,MAAA,OAAKC,UAAU,UAAUC,MAAO,CAAE6C,UAAW,OAAQpC,eAAgB,gBAAiBN,WAAY,UAAWN,SAAA,EAC3GD,EAAAA,EAAAA,KAAA,UACEG,UAAU,MACViC,SAAUxH,GAAQ,EAClBuH,QAASA,IAAMtH,EAAQqJ,GAAKzE,KAAKC,IAAI,EAAGwE,EAAI,IAC5C9D,MAAO,CAAEmC,QAAS3H,GAAQ,EAAI,GAAM,GAAIqF,SACzC,cAGDC,EAAAA,EAAAA,MAAA,QAAME,MAAO,CAAEY,MAAO,UAAWC,SAAU,YAAahB,SAAA,CAAC,QACjDrF,EAAK,OAAK4E,EAAW,KAAGX,EAAarB,OAAO,IAA0B,IAAxBqB,EAAarB,OAAe,WAAa,aAAa,QAE5GwC,EAAAA,EAAAA,KAAA,UACEG,UAAU,MACViC,SAAUxH,GAAQ4E,EAClB2C,QAASA,IAAMtH,EAAQqJ,GAAKzE,KAAK0E,IAAI3E,EAAY0E,EAAI,IACrD9D,MAAO,CAAEmC,QAAS3H,GAAQ4E,EAAa,GAAM,GAAIS,SAClD,iB","sources":["SomaLux/Books/Admin/pages/Categories.jsx","SomaLux/Books/Admin/pages/shared/universityPrefillApi.js"],"sourcesContent":["import React, { useEffect, useState, useMemo } from 'react';\nimport { createCategory, deleteCategory, fetchCategories, updateCategory } from '../api';\nimport { useAdminUI } from '../AdminUIContext';\nimport { supabase } from '../../supabaseClient';\nimport { FiFolder, FiEdit2, FiTrash2, FiPlus, FiBookOpen, FiSearch, FiLoader } from 'react-icons/fi';\nimport { autoFillCategoryDescription } from './shared/universityPrefillApi';\n\nconst Categories = () => {\n  const [rows, setRows] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [adding, setAdding] = useState({ name: '', description: '' });\n  const [editingId, setEditingId] = useState(null);\n  const [draft, setDraft] = useState({ name: '', description: '' });\n  const [page, setPage] = useState(1);\n  const [pageSize] = useState(15);\n  const [bookCounts, setBookCounts] = useState({});\n  const [searchTerm, setSearchTerm] = useState('');\n  const [autoFillingAdd, setAutoFillingAdd] = useState(false);\n  const [autoFillingEdit, setAutoFillingEdit] = useState(false);\n\n  const { confirm, showToast } = useAdminUI();\n\n  const load = async () => {\n    setLoading(true);\n    try {\n      const categories = await fetchCategories();\n      setRows(categories);\n      \n      // Fetch book counts for each category\n      const counts = {};\n      await Promise.all(\n        categories.map(async (cat) => {\n          const { count, error } = await supabase\n            .from('books')\n            .select('*', { count: 'exact', head: true })\n            .eq('category_id', cat.id);\n          \n          if (!error) {\n            counts[cat.id] = count || 0;\n          }\n        })\n      );\n      setBookCounts(counts);\n    } catch (e) {\n      console.error('Failed to load categories:', e);\n      showToast({ type: 'error', message: 'Failed to load categories.' });\n    } finally { \n      setLoading(false); \n    }\n  };\n\n  useEffect(() => { load(); }, []);\n\n  const add = async () => {\n    if (!adding.name.trim()) {\n      showToast({ type: 'error', message: 'Please enter a category name.' });\n      return;\n    }\n    try {\n      await createCategory({ name: adding.name.trim(), description: adding.description || '' });\n      setAdding({ name: '', description: '' });\n      await load();\n      showToast({ type: 'success', message: 'Category added successfully!' });\n    } catch (e) {\n      console.error('Failed to add category:', e);\n      showToast({ type: 'error', message: e?.message || 'Failed to add category.' });\n    }\n  };\n\n  const startEdit = (row) => { \n    setEditingId(row.id); \n    setDraft({ name: row.name, description: row.description || '' }); \n  };\n  \n  const cancel = () => { \n    setEditingId(null); \n    setDraft({ name: '', description: '' }); \n  };\n  \n  const handleAutoFillDescription = async (categoryName, isEditMode = false) => {\n    if (isEditMode) {\n      setAutoFillingEdit(true);\n    } else {\n      setAutoFillingAdd(true);\n    }\n\n    try {\n      const result = await autoFillCategoryDescription(categoryName);\n      \n      if (result && result.description) {\n        if (isEditMode) {\n          setDraft({ ...draft, description: result.description });\n        } else {\n          setAdding({ ...adding, description: result.description });\n        }\n        showToast({ type: 'success', message: `Description auto-filled for ${categoryName}!` });\n      } else {\n        showToast({ type: 'info', message: `No description found for \"${categoryName}\". Please enter manually.` });\n      }\n    } catch (error) {\n      console.error('Error auto-filling description:', error);\n      showToast({ type: 'error', message: 'Failed to auto-fill description. Please try again.' });\n    } finally {\n      if (isEditMode) {\n        setAutoFillingEdit(false);\n      } else {\n        setAutoFillingAdd(false);\n      }\n    }\n  };\n  \n  const save = async (id) => {\n    if (!draft.name.trim()) {\n      showToast({ type: 'error', message: 'Category name cannot be empty.' });\n      return;\n    }\n    try {\n      await updateCategory(id, { name: draft.name.trim(), description: draft.description });\n      cancel();\n      await load();\n      showToast({ type: 'success', message: 'Category updated successfully!' });\n    } catch (e) {\n      console.error('Failed to update category:', e);\n      showToast({ type: 'error', message: e?.message || 'Failed to update category.' });\n    }\n  };\n\n  const handleDelete = async (row) => {\n    const bookCount = bookCounts[row.id] || 0;\n    const ok = await confirm({\n      title: 'Delete category?',\n      message: bookCount > 0 \n        ? `This category contains ${bookCount} book${bookCount > 1 ? 's' : ''}. Deleting it will remove the category association from these books.`\n        : 'This will permanently remove this category.',\n      confirmLabel: 'Delete',\n      cancelLabel: 'Cancel',\n      variant: 'danger',\n    });\n    if (!ok) return;\n    try {\n      await deleteCategory(row.id);\n      await load();\n      showToast({ type: 'success', message: 'Category deleted successfully!' });\n    } catch (e) {\n      console.error('Failed to delete category:', e);\n      showToast({ type: 'error', message: e?.message || 'Failed to delete category.' });\n    }\n  };\n\n  // Filter categories based on search\n  const filteredRows = useMemo(() => {\n    if (!searchTerm.trim()) return rows;\n    const term = searchTerm.toLowerCase();\n    return rows.filter(row => \n      row.name.toLowerCase().includes(term) || \n      (row.description || '').toLowerCase().includes(term)\n    );\n  }, [rows, searchTerm]);\n\n  const paginatedRows = useMemo(() => {\n    const start = (page - 1) * pageSize;\n    const end = start + pageSize;\n    return filteredRows.slice(start, end);\n  }, [filteredRows, page, pageSize]);\n\n  const totalPages = useMemo(() => Math.max(1, Math.ceil(filteredRows.length / pageSize)), [filteredRows.length, pageSize]);\n\n  // Reset to page 1 when search changes\n  useEffect(() => {\n    setPage(1);\n  }, [searchTerm]);\n\n  const totalBooks = useMemo(() => {\n    return Object.values(bookCounts).reduce((sum, count) => sum + count, 0);\n  }, [bookCounts]);\n\n  return (\n    <div>\n      <div className=\"panel\">\n        <div className=\"panel-header\" style={{ marginBottom: '1.5rem' }}>\n          <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>\n            <div style={{ \n              width: '40px', \n              height: '40px', \n              borderRadius: '10px', \n              background: 'linear-gradient(135deg, #00a884 0%, #008069 100%)',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center'\n            }}>\n              <FiFolder size={20} color=\"#fff\" />\n            </div>\n            <div>\n              <div className=\"panel-title\" style={{ marginBottom: '0.25rem' }}>Categories</div>\n              <div style={{ fontSize: '0.875rem', color: '#8696a0' }}>\n                {rows.length} {rows.length === 1 ? 'category' : 'categories'} â€¢ {totalBooks} total books\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Search Bar */}\n        <div style={{ marginBottom: '1rem' }}>\n          <div style={{ position: 'relative' }}>\n            <FiSearch \n              size={18} \n              style={{ \n                position: 'absolute', \n                left: '12px', \n                top: '50%', \n                transform: 'translateY(-50%)', \n                color: '#8696a0' \n              }} \n            />\n            <input \n              className=\"input\" \n              value={searchTerm} \n              onChange={(e) => setSearchTerm(e.target.value)} \n              placeholder=\"Search categories...\" \n              style={{ paddingLeft: '40px' }}\n            />\n          </div>\n        </div>\n\n        {/* Add Category Form */}\n        <div style={{ \n          background: 'rgba(0, 168, 132, 0.05)', \n          border: '1px solid rgba(0, 168, 132, 0.2)',\n          borderRadius: '12px',\n          padding: '1rem',\n          marginBottom: '1.5rem'\n        }}>\n          <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.75rem' }}>\n            <FiPlus size={18} color=\"#00a884\" />\n            <span style={{ color: '#e9edef', fontWeight: '500' }}>Add New Category</span>\n          </div>\n          <div className=\"grid-2\" style={{ marginBottom: '0.4rem' }}>\n            <div>\n              <label className=\"label\" style={{ marginBottom: '0.3rem', fontSize: '0.85rem' }}>Name *</label>\n              <input \n                className=\"input\" \n                value={adding.name} \n                onChange={(e) => setAdding({ ...adding, name: e.target.value })} \n                placeholder=\"e.g., Science Fiction\"\n                style={{ fontSize: '0.9rem', padding: '0.4rem 0.6rem' }}\n                onKeyPress={(e) => e.key === 'Enter' && add()}\n              />\n            </div>\n            <div>\n              <label className=\"label\" style={{ marginBottom: '0.3rem', fontSize: '0.85rem' }}>Description</label>\n              <div style={{ position: 'relative' }}>\n                <input \n                  className=\"input\" \n                  value={adding.description} \n                  onChange={(e) => setAdding({ ...adding, description: e.target.value })} \n                  placeholder=\"Optional description\"\n                  style={{ fontSize: '0.9rem', padding: '0.4rem 0.6rem', paddingRight: '75px' }}\n                  onKeyPress={(e) => e.key === 'Enter' && add()}\n                />\n                <button \n                  onClick={() => handleAutoFillDescription(adding.name, false)}\n                  disabled={!adding.name || autoFillingAdd}\n                  style={{\n                    position: 'absolute',\n                    right: '8px',\n                    top: '50%',\n                    transform: 'translateY(-50%)',\n                    background: '#00a884',\n                    color: 'white',\n                    border: 'none',\n                    padding: '4px 8px',\n                    borderRadius: '4px',\n                    cursor: adding.name && !autoFillingAdd ? 'pointer' : 'not-allowed',\n                    fontSize: '11px',\n                    opacity: adding.name && !autoFillingAdd ? 1 : 0.5,\n                    display: 'flex',\n                    alignItems: 'center',\n                    gap: '3px',\n                    whiteSpace: 'nowrap'\n                  }}\n                  title=\"Auto-fill description\"\n                >\n                  {autoFillingAdd ? <><FiLoader className=\"spin\" style={{ fontSize: '12px' }} /> Fill</> : <>Fill</>}\n                </button>\n              </div>\n            </div>\n          </div>\n          <div className=\"actions\">\n            <button className=\"btn primary\" onClick={add}>\n              <FiPlus size={16} /> Add Category\n            </button>\n          </div>\n        </div>\n\n        {/* Categories Table */}\n        <div style={{ overflowX: 'auto' }}>\n          <table className=\"table\">\n            <thead>\n              <tr>\n                <th style={{ width: '35%' }}>Category</th>\n                <th style={{ width: '40%' }}>Description</th>\n                <th style={{ width: '15%', textAlign: 'center' }}>Books</th>\n                <th style={{ width: '10%', textAlign: 'right' }}>Actions</th>\n              </tr>\n            </thead>\n            <tbody>\n              {loading ? (\n                <tr>\n                  <td colSpan={4} style={{ color: '#8696a0', textAlign: 'center', padding: '2rem' }}>\n                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>\n                      <div className=\"spinner\" style={{ width: '24px', height: '24px', borderWidth: '3px' }} />\n                      <span>Loading categories...</span>\n                    </div>\n                  </td>\n                </tr>\n              ) : paginatedRows.length === 0 ? (\n                <tr>\n                  <td colSpan={4} style={{ color: '#8696a0', textAlign: 'center', padding: '2rem' }}>\n                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>\n                      <FiFolder size={32} color=\"#8696a0\" />\n                      <span>{searchTerm ? 'No categories found matching your search' : 'No categories yet'}</span>\n                      {searchTerm && (\n                        <button \n                          className=\"btn\" \n                          onClick={() => setSearchTerm('')}\n                          style={{ marginTop: '0.5rem' }}\n                        >\n                          Clear search\n                        </button>\n                      )}\n                    </div>\n                  </td>\n                </tr>\n              ) : paginatedRows.map(row => (\n                <tr key={row.id}>\n                  <td>\n                    {editingId === row.id ? (\n                      <input \n                        className=\"input\" \n                        value={draft.name} \n                        onChange={(e) => setDraft({ ...draft, name: e.target.value })} \n                        autoFocus\n                      />\n                    ) : (\n                      <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>\n                        <div style={{ \n                          width: '32px', \n                          height: '32px', \n                          borderRadius: '8px', \n                          background: 'rgba(0, 168, 132, 0.1)',\n                          display: 'flex',\n                          alignItems: 'center',\n                          justifyContent: 'center',\n                          flexShrink: 0\n                        }}>\n                          <FiFolder size={16} color=\"#00a884\" />\n                        </div>\n                        <span style={{ fontWeight: '500', color: '#e9edef' }}>{row.name}</span>\n                      </div>\n                    )}\n                  </td>\n                  <td>\n                    {editingId === row.id ? (\n                      <div style={{ position: 'relative' }}>\n                        <input \n                          className=\"input\" \n                          value={draft.description} \n                          onChange={(e) => setDraft({ ...draft, description: e.target.value })}\n                          style={{ paddingRight: '75px' }}\n                        />\n                        <button \n                          onClick={() => handleAutoFillDescription(draft.name, true)}\n                          disabled={!draft.name || autoFillingEdit}\n                          style={{\n                            position: 'absolute',\n                            right: '8px',\n                            top: '50%',\n                            transform: 'translateY(-50%)',\n                            background: '#00a884',\n                            color: 'white',\n                            border: 'none',\n                            padding: '4px 8px',\n                            borderRadius: '4px',\n                            cursor: draft.name && !autoFillingEdit ? 'pointer' : 'not-allowed',\n                            fontSize: '11px',\n                            opacity: draft.name && !autoFillingEdit ? 1 : 0.5,\n                            display: 'flex',\n                            alignItems: 'center',\n                            gap: '3px',\n                            whiteSpace: 'nowrap'\n                          }}\n                          title=\"Auto-fill description\"\n                        >\n                          {autoFillingEdit ? <><FiLoader className=\"spin\" style={{ fontSize: '12px' }} /> Fill</> : <>Fill</>}\n                        </button>\n                      </div>\n                    ) : (\n                      <span style={{ color: row.description ? '#cfd8dc' : '#8696a0', fontStyle: row.description ? 'normal' : 'italic' }}>\n                        {row.description || 'No description'}\n                      </span>\n                    )}\n                  </td>\n                  <td style={{ textAlign: 'center' }}>\n                    <div style={{ \n                      display: 'inline-flex',\n                      alignItems: 'center',\n                      gap: '0.375rem',\n                      background: bookCounts[row.id] > 0 ? 'rgba(0, 168, 132, 0.1)' : 'rgba(134, 150, 160, 0.1)',\n                      color: bookCounts[row.id] > 0 ? '#00a884' : '#8696a0',\n                      padding: '0.25rem 0.75rem',\n                      borderRadius: '20px',\n                      fontSize: '0.875rem',\n                      fontWeight: '500'\n                    }}>\n                      <FiBookOpen size={14} />\n                      {bookCounts[row.id] || 0}\n                    </div>\n                  </td>\n                  <td>\n                    {editingId === row.id ? (\n                      <div className=\"actions\" style={{ justifyContent: 'flex-end' }}>\n                        <button className=\"btn primary\" onClick={() => save(row.id)} style={{ fontSize: '0.875rem' }}>\n                          Save\n                        </button>\n                        <button className=\"btn\" onClick={cancel} style={{ fontSize: '0.875rem' }}>\n                          Cancel\n                        </button>\n                      </div>\n                    ) : (\n                      <div className=\"actions\" style={{ justifyContent: 'flex-end' }}>\n                        <button \n                          className=\"btn\" \n                          onClick={() => startEdit(row)}\n                          style={{ padding: '0.5rem', minWidth: 'auto' }}\n                          title=\"Edit category\"\n                        >\n                          <FiEdit2 size={16} />\n                        </button>\n                        <button\n                          className=\"btn\"\n                          onClick={() => handleDelete(row)}\n                          style={{ padding: '0.5rem', minWidth: 'auto', color: '#ff4444' }}\n                          title=\"Delete category\"\n                        >\n                          <FiTrash2 size={16} />\n                        </button>\n                      </div>\n                    )}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n        \n        {/* Pagination */}\n        {filteredRows.length > 0 && (\n          <div className=\"actions\" style={{ marginTop: '1rem', justifyContent: 'space-between', alignItems: 'center' }}>\n            <button \n              className=\"btn\" \n              disabled={page <= 1} \n              onClick={() => setPage(p => Math.max(1, p - 1))}\n              style={{ opacity: page <= 1 ? 0.5 : 1 }}\n            >\n              Previous\n            </button>\n            <span style={{ color: '#cfd8dc', fontSize: '0.875rem' }}>\n              Page {page} of {totalPages} ({filteredRows.length} {filteredRows.length === 1 ? 'category' : 'categories'})\n            </span>\n            <button \n              className=\"btn\" \n              disabled={page >= totalPages} \n              onClick={() => setPage(p => Math.min(totalPages, p + 1))}\n              style={{ opacity: page >= totalPages ? 0.5 : 1 }}\n            >\n              Next\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Categories;","import { supabase } from '../../../supabaseClient';\n\n// API Configuration\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\nconst USE_BACKEND_PROXY = true; // Set to false to use direct API calls\n\n/**\n * Search for university names for autocomplete\n */\nexport async function searchUniversityNames(query, limit = 10) {\n  try {\n    // Check cache first\n    let { data, error } = await supabase\n      .rpc('search_university_names', { p_query: query, p_limit: limit });\n\n    if (error) throw error;\n    if (data?.length) return data;\n\n    // Try Wikipedia/Wikidata search as primary method (more reliable, no API key needed)\n    const wikiResults = await searchWikipediaUniversities(query, limit);\n    if (wikiResults.length > 0) {\n      // Cache results\n      await Promise.all(wikiResults.map(uni => \n        cacheUniversityPrefillData(uni.name, uni, 'wikipedia')\n      ));\n      return wikiResults;\n    }\n\n    // Try backend proxy for Google Knowledge Graph (if enabled)\n    if (USE_BACKEND_PROXY) {\n      try {\n        const response = await fetch(`${API_URL}/api/university/search?query=${encodeURIComponent(query)}&limit=${limit}`);\n        \n        if (response.ok) {\n          const data = await response.json();\n          const universities = data.universities || [];\n          \n          // Cache results\n          if (universities.length > 0) {\n            await Promise.all(universities.map(uni => \n              cacheUniversityPrefillData(uni.name, uni, 'google_proxy')\n            ));\n          }\n          \n          return universities;\n        }\n      } catch (proxyError) {\n        console.warn('Backend proxy unavailable:', proxyError.message);\n      }\n    }\n\n    return [];\n  } catch (error) {\n    console.error('Error searching university names:', error);\n    return [];\n  }\n}\n\n/**\n * Search for universities using Wikipedia API (more reliable, no API key needed)\n */\nasync function searchWikipediaUniversities(query, limit = 10) {\n  try {\n    const searchUrl = `https://en.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(query + ' university')}&limit=${limit}&namespace=0&format=json&origin=*`;\n    const response = await fetch(searchUrl);\n    \n    if (!response.ok) return [];\n    \n    const data = await response.json();\n    // data[0] = query, data[1] = titles, data[2] = descriptions, data[3] = urls\n    const titles = data[1] || [];\n    const descriptions = data[2] || [];\n    const urls = data[3] || [];\n    \n    return titles\n      .filter(title => title.toLowerCase().includes('university') || title.toLowerCase().includes('college'))\n      .map((title, index) => ({\n        name: title,\n        description: descriptions[index] || '',\n        website_url: urls[index] || '',\n      }));\n  } catch (error) {\n    console.error('Error searching Wikipedia:', error);\n    return [];\n  }\n}\n\n/**\n * Get prefill data for a university by name from cache\n */\nexport async function getUniversityPrefillData(universityName) {\n  try {\n    const { data, error } = await supabase\n      .rpc('get_university_prefill_data', {\n        p_university_name: universityName,\n      });\n\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error fetching prefill data:', error);\n    return null;\n  }\n}\n\n/**\n * Fetch university data from Google Knowledge Graph (via backend proxy)\n */\nexport async function fetchUniversityDataFromGoogle(universityName) {\n  if (USE_BACKEND_PROXY) {\n    try {\n      const response = await fetch(`${API_URL}/api/university/details?name=${encodeURIComponent(universityName)}`);\n      \n      if (response.ok) {\n        const data = await response.json();\n        return {\n          name: data.university.name || universityName,\n          description: data.university.description || '',\n          website_url: data.university.website_url || '',\n          location: data.university.location || '',\n          established: null,\n          student_count: null,\n          cover_images: data.university.image ? [data.university.image] : [],\n        };\n      }\n    } catch (error) {\n      console.error('Error fetching from Google via proxy:', error);\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Fetch university summary from Wikipedia REST API\n */\nexport async function fetchUniversityDataFromWikipedia(universityName) {\n  try {\n    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(universityName)}`;\n    const res = await fetch(url);\n    if (!res.ok) return null;\n    const json = await res.json();\n\n    return {\n      name: json.title || universityName,\n      description: json.extract || '',\n      website_url: '',\n      location: '',\n      established: null,\n      student_count: null,\n      cover_images: json.thumbnail?.source ? [json.thumbnail.source] : [],\n    };\n  } catch (e) {\n    console.error('Error fetching from Wikipedia REST:', e);\n    return null;\n  }\n}\n\n/**\n * Fetch university data from Wikidata\n */\nexport async function fetchUniversityDataFromWikidata(universityName) {\n  try {\n    const sparqlQuery = `\n      SELECT ?item ?itemLabel ?locationLabel ?established ?studentCount ?website\n      WHERE {\n        ?item wdt:P31/wdt:P279* wd:Q3918;\n              rdfs:label ?itemLabel.\n        OPTIONAL { ?item wdt:P131 ?location. }\n        OPTIONAL { ?item wdt:P571 ?established. }\n        OPTIONAL { ?item wdt:P2196 ?studentCount. }\n        OPTIONAL { ?item wdt:P856 ?website. }\n        FILTER(CONTAINS(LCASE(?itemLabel), LCASE(\"${universityName}\")))\n        FILTER(LANG(?itemLabel) = \"en\")\n        SERVICE wikibase:label { bd:serviceParam wikibase:language \"en\". }\n      }\n      LIMIT 1\n    `;\n    const url = `https://query.wikidata.org/sparql?query=${encodeURIComponent(sparqlQuery)}&format=json`;\n    const response = await fetch(url);\n    if (!response.ok) return null;\n\n    const data = await response.json();\n    const binding = data.results.bindings[0];\n\n    if (!binding) return null;\n\n    return {\n      name: binding.itemLabel.value,\n      description: '',\n      website_url: binding.website?.value || '',\n      location: binding.locationLabel?.value || '',\n      established: binding.established?.value ? new Date(binding.established.value).getFullYear() : null,\n      student_count: binding.studentCount?.value || null,\n      cover_images: [],\n    };\n  } catch (error) {\n    console.error('Error fetching from Wikidata:', error);\n    return null;\n  }\n}\n\n/**\n * Fetch Wikimedia Commons images for a university\n */\nexport async function fetchWikimediaImages(universityName) {\n  try {\n    const title = (universityName || '').trim().replace(/\\s+/g, '_');\n    if (!title) return [];\n\n    const listUrl = `https://commons.wikimedia.org/w/api.php?action=query&format=json&origin=*&prop=images&titles=${encodeURIComponent(title)}`;\n    const listRes = await fetch(listUrl);\n    if (!listRes.ok) return [];\n    const listJson = await listRes.json();\n\n    const pages = listJson?.query?.pages ? Object.values(listJson.query.pages) : [];\n    const images = pages[0]?.images || [];\n    if (!images.length) return [];\n\n    const fileTitles = images\n      .map((img) => img?.title)\n      .filter(Boolean)\n      .slice(0, 50)\n      .join('|');\n\n    if (!fileTitles) return [];\n\n    const infoUrl = `https://commons.wikimedia.org/w/api.php?action=query&format=json&origin=*&prop=imageinfo&iiprop=url&titles=${encodeURIComponent(fileTitles)}`;\n    const infoRes = await fetch(infoUrl);\n    if (!infoRes.ok) return [];\n    const infoJson = await infoRes.json();\n\n    const filePages = infoJson?.query?.pages ? Object.values(infoJson.query.pages) : [];\n    const urls = filePages\n      .map((p) => p?.imageinfo?.[0]?.url)\n      .filter((u) => typeof u === 'string' && /\\.(jpg|jpeg|png|webp)$/i.test(u));\n\n    const prioritized = urls.sort((a, b) => {\n      const deprioritize = (s) => /logo|seal|coat_of_arms|emblem/i.test(s) ? 1 : 0;\n      return deprioritize(a) - deprioritize(b);\n    });\n\n    return prioritized.slice(0, 5);\n  } catch (e) {\n    console.error('Error fetching Wikimedia images:', e);\n    return [];\n  }\n}\n\n/**\n * Fetch images from Unsplash (via backend proxy if enabled)\n */\nexport async function fetchUnsplashImages(universityName) {\n  if (USE_BACKEND_PROXY) {\n    try {\n      const response = await fetch(`${API_URL}/api/university/images?query=${encodeURIComponent(universityName)}`);\n      \n      if (response.ok) {\n        const data = await response.json();\n        return data.images?.map(img => img.url) || [];\n      }\n    } catch (error) {\n      console.error('Error fetching Unsplash images via proxy:', error);\n    }\n  }\n  \n  return [];\n}\n\n/**\n * Download image from URL and convert to File object\n */\nexport async function downloadImageAsFile(imageUrl, fileName) {\n  try {\n    const response = await fetch(imageUrl);\n    if (!response.ok) throw new Error('Failed to download image');\n\n    const blob = await response.blob();\n    const file = new File([blob], fileName, { type: blob.type });\n    return file;\n  } catch (error) {\n    console.error('Error downloading image:', error);\n    return null;\n  }\n}\n\n/**\n * Cache university prefill data\n */\nexport async function cacheUniversityPrefillData(universityName, data, source = 'manual') {\n  try {\n    const { error } = await supabase\n      .from('university_prefill_cache')\n      .upsert({\n        university_name: universityName,\n        data: data,\n        source: source,\n        updated_at: new Date().toISOString(),\n      });\n\n    if (error) throw error;\n    return true;\n  } catch (error) {\n    console.error('Error caching prefill data:', error);\n    return false;\n  }\n}\n\n/**\n * Upload multiple images for a university\n */\nexport async function uploadUniversityImages(universityId, imageFiles) {\n  try {\n    const uploadedImages = [];\n    const bucket = 'university-covers';\n\n    for (let i = 0; i < imageFiles.length; i++) {\n      const file = imageFiles[i];\n      const fileExt = file.name.split('.').pop();\n      const fileName = `${universityId}/image_${i + 1}_${Date.now()}.${fileExt}`;\n\n      const { error: uploadError } = await supabase.storage\n        .from(bucket)\n        .upload(fileName, file, {\n          cacheControl: '3600',\n          upsert: false,\n        });\n\n      if (uploadError) {\n        console.error('Error uploading image:', uploadError);\n        continue;\n      }\n\n      const { data: urlData } = supabase.storage\n        .from(bucket)\n        .getPublicUrl(fileName);\n\n      uploadedImages.push({\n        url: urlData.publicUrl,\n        fileName: fileName,\n      });\n    }\n\n    return uploadedImages;\n  } catch (error) {\n    console.error('Error uploading multiple images:', error);\n    throw error;\n  }\n}\n\n/**\n * Add image record to university_images table\n */\nexport async function addUniversityImage(universityId, imageUrl, caption = null, isPrimary = false, displayOrder = 0) {\n  try {\n    const { data, error } = await supabase\n      .rpc('add_university_image', {\n        p_university_id: universityId,\n        p_image_url: imageUrl,\n        p_caption: caption,\n        p_is_primary: isPrimary,\n        p_display_order: displayOrder,\n      });\n\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error adding university image:', error);\n    throw error;\n  }\n}\n\n/**\n * Get all images for a university\n */\nexport async function getUniversityImages(universityId) {\n  try {\n    const { data, error } = await supabase\n      .from('university_images')\n      .select('*')\n      .eq('university_id', universityId)\n      .order('is_primary', { ascending: false })\n      .order('display_order', { ascending: true });\n\n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error fetching university images:', error);\n    throw error;\n  }\n}\n\n/**\n * Set image as primary\n */\nexport async function setPrimaryUniversityImage(imageId) {\n  try {\n    const { error } = await supabase\n      .rpc('set_primary_university_image', {\n        p_image_id: imageId,\n      });\n\n    if (error) throw error;\n    return true;\n  } catch (error) {\n    console.error('Error setting primary image:', error);\n    return false;\n  }\n}\n\n/**\n * Delete university image\n */\nexport async function deleteUniversityImage(imageId, imageUrl) {\n  try {\n    const urlParts = imageUrl.split('/');\n    const bucket = 'university-covers';\n    const filePath = urlParts.slice(urlParts.indexOf(bucket) + 1).join('/');\n\n    const { error: storageError } = await supabase.storage\n      .from(bucket)\n      .remove([filePath]);\n\n    if (storageError) {\n      console.error('Error deleting from storage:', storageError);\n    }\n\n    const { error: dbError } = await supabase\n      .from('university_images')\n      .delete()\n      .eq('id', imageId);\n\n    if (dbError) throw dbError;\n    return true;\n  } catch (error) {\n    console.error('Error deleting university image:', error);\n    throw error;\n  }\n}\n\n/**\n * Main auto-fill function triggered on tab/input\n */\nexport async function autoFillUniversityData(universityName) {\n  try {\n    // Check cache first\n    let data = await getUniversityPrefillData(universityName);\n    if (data) return data;\n\n    // Prefer Wikipedia + Wikidata for accuracy (no API keys needed)\n    const wikiSummary = await fetchUniversityDataFromWikipedia(universityName);\n    const wikidata = await fetchUniversityDataFromWikidata(universityName);\n\n    if (wikiSummary || wikidata) {\n      const merged = {\n        name: (wikiSummary?.name || wikidata?.name || universityName) ?? universityName,\n        description: wikiSummary?.description || '',\n        website_url: wikidata?.website_url || '',\n        location: wikidata?.location || '',\n        established: wikidata?.established ?? null,\n        student_count: wikidata?.student_count ?? null,\n        cover_images: wikiSummary?.cover_images || [],\n      };\n      data = merged;\n    }\n\n    // Try Google as last resort (via proxy if enabled)\n    if (!data) {\n      data = await fetchUniversityDataFromGoogle(universityName);\n    }\n\n    // Fetch images\n    if (data && (!data.cover_images || data.cover_images.length === 0)) {\n      const commons = await fetchWikimediaImages(data.name || universityName);\n      if (commons.length) {\n        data.cover_images = commons;\n      } else {\n        const unsplash = await fetchUnsplashImages(data.name || universityName);\n        data.cover_images = unsplash;\n      }\n    }\n\n    // Cache the result\n    if (data) {\n      await cacheUniversityPrefillData(universityName, data, 'wikipedia_wikidata');\n    }\n\n    return (\n      data || {\n        name: universityName,\n        description: '',\n        website_url: '',\n        location: '',\n        established: null,\n        student_count: null,\n        cover_images: [],\n      }\n    );\n  } catch (error) {\n    console.error('Error auto-filling university data:', error);\n    return {\n      name: universityName,\n      description: '',\n      website_url: '',\n      location: '',\n      established: null,\n      student_count: null,\n      cover_images: [],\n    };\n  }\n}\n\n/**\n * Get all cached universities for dropdown/autocomplete\n */\nexport async function getAllCachedUniversities() {\n  try {\n    const { data, error } = await supabase\n      .from('university_prefill_cache')\n      .select('university_name')\n      .order('university_name');\n\n    if (error) throw error;\n    return data?.map(u => u.university_name) || [];\n  } catch (error) {\n    console.error('Error fetching cached universities:', error);\n    return [];\n  }\n}\n\n/**\n * Debounce utility\n */\nfunction debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n/**\n * Frontend integration for auto-fill\n */\nexport function setupAutoFill(inputElement, resultContainer) {\n  inputElement.addEventListener(\n    'input',\n    debounce(async () => {\n      const query = inputElement.value.trim();\n      if (query.length < 3) return;\n\n      const suggestions = await searchUniversityNames(query);\n      console.log('Suggestions:', suggestions);\n      \n      const datalist = document.createElement('datalist');\n      datalist.id = 'university-suggestions';\n      suggestions.forEach(s => {\n        const option = document.createElement('option');\n        option.value = s.name;\n        datalist.appendChild(option);\n      });\n      inputElement.setAttribute('list', 'university-suggestions');\n      inputElement.parentNode.appendChild(datalist);\n    }, 300)\n  );\n\n  inputElement.addEventListener('keydown', async (event) => {\n    if (event.key === 'Tab') {\n      event.preventDefault();\n      const universityName = inputElement.value.trim();\n      if (!universityName) return;\n\n      const data = await autoFillUniversityData(universityName);\n      if (data) {\n        resultContainer.innerHTML = `\n          <h3>${data.name}</h3>\n          <p>${data.description || 'No description available'}</p>\n          <a href=\"${data.website_url || '#'}\" target=\"_blank\">Website</a>\n          <p>Location: ${data.location || 'N/A'}</p>\n          <p>Established: ${data.established || 'N/A'}</p>\n          <p>Students: ${data.student_count || 'N/A'}</p>\n          <div>\n            ${data.cover_images\n              .map(img => `<img src=\"${img}\" alt=\"${data.name} campus\" width=\"200\" style=\"margin-right: 10px;\" />`)\n              .join('')}\n          </div>\n        `;\n      }\n    }\n  });\n}\n\n/**\n * Auto-fill category description using Wikipedia/Wikidata\n */\nexport async function autoFillCategoryDescription(categoryName) {\n  try {\n    // For categories, we'll generate a description based on the category name\n    // by fetching information from Wikipedia about the topic\n    \n    const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(categoryName)}&prop=extracts&exintro=true&explaintext=true&format=json&origin=*`;\n    const response = await fetch(searchUrl);\n    \n    if (!response.ok) return null;\n    \n    const data = await response.json();\n    const pages = data.query.pages;\n    \n    // Get the first page result\n    const pageId = Object.keys(pages)[0];\n    const page = pages[pageId];\n    \n    if (page.extract) {\n      // Clean up the extract - take first sentence or first ~200 characters\n      let description = page.extract;\n      \n      // Try to get the first sentence\n      const firstSentenceMatch = description.match(/^[^.!?]*[.!?]/);\n      if (firstSentenceMatch) {\n        description = firstSentenceMatch[0];\n      } else if (description.length > 200) {\n        // If no punctuation, truncate and add ellipsis\n        description = description.substring(0, 200) + '...';\n      }\n      \n      return {\n        description: description.trim(),\n        source: 'wikipedia'\n      };\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Error fetching category description:', error);\n    return null;\n  }\n}"],"names":["Categories","rows","setRows","useState","loading","setLoading","adding","setAdding","name","description","editingId","setEditingId","draft","setDraft","page","setPage","pageSize","bookCounts","setBookCounts","searchTerm","setSearchTerm","autoFillingAdd","setAutoFillingAdd","autoFillingEdit","setAutoFillingEdit","confirm","showToast","useAdminUI","load","async","categories","fetchCategories","counts","Promise","all","map","count","error","supabase","from","select","head","eq","cat","id","e","console","type","message","useEffect","add","trim","createCategory","cancel","handleAutoFillDescription","categoryName","isEditMode","arguments","length","undefined","result","searchUrl","concat","encodeURIComponent","response","fetch","ok","pages","json","query","Object","keys","extract","firstSentenceMatch","match","substring","source","autoFillCategoryDescription","_objectSpread","filteredRows","useMemo","term","toLowerCase","filter","row","includes","paginatedRows","start","end","slice","totalPages","Math","max","ceil","totalBooks","values","reduce","sum","_jsx","children","_jsxs","className","style","marginBottom","display","alignItems","gap","width","height","borderRadius","background","justifyContent","FiFolder","size","color","fontSize","position","FiSearch","left","top","transform","value","onChange","target","placeholder","paddingLeft","border","padding","FiPlus","fontWeight","onKeyPress","key","paddingRight","onClick","disabled","right","cursor","opacity","whiteSpace","title","_Fragment","FiLoader","overflowX","textAlign","colSpan","flexDirection","borderWidth","marginTop","autoFocus","flexShrink","fontStyle","FiBookOpen","updateCategory","save","startEdit","minWidth","FiEdit2","bookCount","confirmLabel","cancelLabel","variant","deleteCategory","handleDelete","FiTrash2","p","min"],"ignoreList":[],"sourceRoot":""}